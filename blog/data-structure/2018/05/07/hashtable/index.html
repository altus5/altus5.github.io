<!doctype html><html dir=ltr lang=ja><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=alternate hreflang=ja href=https://www.altus5.co.jp/ ><title>「ハッシュ」完全理解のための覚書 ハッシュテーブルをRubyで実装してみる | ALTUS-FIVE</title><meta name=description content=「ハッシュ関数」「ハッシュ値」「ハッシュテーブル」についてごまかしなく理解することを目的に、Rubyでハッシュテーブルクラスを自作してみました。ソースコードは100行に満たないので、コードリーディングを通じたデータ構造の理解にお役立てください。><meta name=viewport content="width=device-width,initial-scale=1"><meta property=og:title content="「ハッシュ」完全理解のための覚書 ハッシュテーブルをRubyで実装してみる | ALTUS-FIVE"><meta property=og:type content=website><meta property=og:url content=https://www.altus5.co.jp><meta property=og:description content=「ハッシュ関数」「ハッシュ値」「ハッシュテーブル」についてごまかしなく理解することを目的に、Rubyでハッシュテーブルクラスを自作してみました。ソースコードは100行に満たないので、コードリーディングを通じたデータ構造の理解にお役立てください。><meta property=og:site_name content=ALTUS-FIVE><meta property=og:image content=https://www.altus5.co.jp/images/ogp.png><meta name=twitter:card content=summary><meta name=twitter:url content=https://www.altus5.co.jp><meta name=twitter:title content="「ハッシュ」完全理解のための覚書 ハッシュテーブルをRubyで実装してみる | ALTUS-FIVE"><meta name=twitter:description content=「ハッシュ関数」「ハッシュ値」「ハッシュテーブル」についてごまかしなく理解することを目的に、Rubyでハッシュテーブルクラスを自作してみました。ソースコードは100行に満たないので、コードリーディングを通じたデータ構造の理解にお役立てください。><meta name=twitter:image content=https://www.altus5.co.jp/images/ogp.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple_touch_icon180x180.png><link rel=apple-touch-icon sizes=152x152 href=/images/apple_touch_icon152x152.png><link rel=apple-touch-icon sizes=120x120 href=/images/apple_touch_icon120x120.png><link rel=apple-touch-icon sizes=76x76 href=/images/apple_touch_icon76x76.png><link href=https://www.altus5.co.jp/feed.xml rel=alternate type=application/atom+xml><link rel=stylesheet href="/styles/common.css?rev=8b1b5b6baabfd0e227afbbbf65f3f876"><script src=https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js></script><script src=/scripts/gist-embed.min.js></script><link rel=stylesheet href="/styles/blog.css?rev=91052963bc4d9e7323a23dd1555b90ac"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/emojione@4.0.0/extras/css/emojione.min.css><body><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5WGNWC" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5WGNWC');</script><!--[if lt IE 9]>
    <p class="browserupgrade">
      <strong>古い</strong>ブラウザをご使用されています。
      本サイトを快適に閲覧頂くために、<a href="http://browsehappy.com/">新しいブラウザにアップグレード</a>してください。
    </p>
  <![endif]--><header id=_header><nav class="w_const cf"><h1 class=logo_head><a href=/ ><img src=/images/logo_header.png alt=ALTUS-FIVE（アルタスファイブ）></a></h1><ul class=links><li class=link><a href=/#introduction>アルタスファイブとは</a><li class=link><a href=/#feature>強み</a><li class=link><a href=/#service>サービス</a><li class=link><a href=/#performance>実績</a><li class=link><a href=/#example>開発事例</a><li class=link><a href=/blog/ >ブログ</a><li class=link><a href=/recruit/ >採用情報</a><li class=link><a href=/company/ >会社概要</a><li class="link link_contact"><a href=/contact/ >お問い合わせ</a></ul></nav></header><div id=blog_page class=wrap_all><article id=blog class=article><section class="blog__title w_const"><span>「ハッシュ」完全理解のための覚書 ハッシュテーブルをRubyで実装してみる</span></section><div class="article__conts w_const cf"><div id=blog-content><div id=blog-subtitle class=cf><div id=blog-date>2018/05/07</div><div id=blog-tags><ul class=tag-uline><li class="tag-uline-label tag__6"><a href=/blog/tag/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/ >データ構造</a><li class="tag-uline-label tag__7"><a href=/blog/tag/%E5%AE%9F%E8%A3%85/ >実装</a><li class="tag-uline-label tag__10"><a href=/blog/tag/%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB/ >ハッシュテーブル</a><li class="tag-uline-label tag__9"><a href=/blog/tag/Ruby/ >Ruby</a></ul></div></div><div class=markdown-body><h2 id=->「ハッシュ」を完全理解するための道とは</h2><p>前回、エンジニアが常々お世話になる「連想配列」についてのあれこれを述べました。Rubyのシンタックスシュガーを使って、 <strong><a href=https://www.altus5.co.jp/blog/data-structure/2018/05/07/associative-array/ >配列を連想配列に魔改造</a>することで、どんな性能の連想配列になるかを確かめる</strong> ことが前回の内容でした。<p>今回は、連想配列実装の正式な(?)方法、<strong>ハッシュテーブルを実際に作ってみよう</strong> という試みです。粗悪な性能の連想配列だけでなく、実用性の高い連想配列も、さほど長くないコードで実現できるんです。<p>Rubyでの実装を通じて「ハッシュ」を（なんとなくではなく）理解しよう、というのが本記事のゴールになります。<p><strong>注釈</strong> ハッシュの完全理解とは言いつつも、今回 <strong>暗号化の話には触れない</strong> ので、その旨ご注意頂ければ幸いです。 ただし、暗号化についても今回の話と基本は同一ですので、理解の助けになるはずです。<h3 id=->実装が理解への近道だ</h3><p>筆者は学生時代にハッシュテーブルを自作して、その性能の良さ（要素へのアクセスの機敏さ）に感動した人間であることを <a href=https://www.altus5.co.jp/blog/data-structure/2018/05/07/associative-array/ >前回</a> 述べました。<ul><li><a href=https://www.altus5.co.jp/blog/data-structure/2018/05/07/associative-array/ >Rubyの配列(Array)を魔改造して、連想配列として使ってみた</a></ul><p>ハッシュテーブルについて書かれた（まともな）文献については、「ハッシュ」と名のつく用語が複数出てきます。ハッシュ関数、ハッシュ値、などなど。<p>その関連性については色々な喩えがあるものの、 keyの成績や身長などが引き合いに出され、 <strong>それ内部ロジックどーなってんのよ？</strong> と言いたくなるような例が用いられたりしており、 「とりあえず」の理解の助けにはなるものの、エンジニアにとっては少し物足りない記述になっているように思えます。<p>本記事の内容は、下記の2つの項目について理解するにあたっては、なかなか良い内容なのではないかと自負しています。<ol><li>ハッシュ関数は、文字列など仕様によって規定されるいかなるkeyも入力できる形式でなければならない<ul><li>その役割はハッシュ値を発行し、メモリ上の要素の格納場所を決めることである</ul><li>異なるkeyに対するハッシュ値は、可能な限り重複がないことが望ましい<ul><li>そのような性質を満たす「よい」ハッシュ関数のうち、極めてシンプルな実装のものも存在する（後述）</ul></ol><p>また、本記事では <strong>下記３つの用語について、明確に区別すること</strong> をゴールとして、ハッシュテーブルの仕組みについてまとめていきます。<ol><li>ハッシュ関数<li>ハッシュ値<li>ハッシュテーブル（ハッシュ）</ol><p>最後に、ハッシュテーブルの性能について書かれた文献を読むと、たいてい <strong>「定数時間O(1)で要素にアクセスできる（ゆえに早い、最高だ！）」</strong> と書かれています。 一体これがどういうことなのかも、分かりやすい解説をあまり見かけたことがありません。この点にも、チャレンジしてみたいと思います。<h2 id=->ハッシュ関数の設計</h2><p>ハッシュテーブルの実装に必要な <strong>最重要のメソッド</strong> がハッシュ関数です。<p>ここでは、文字列をkeyとするハッシュテーブルをユースケースとして想定し、 ハッシュ関数をRubyのメソッドとして、一から実装してみたいと思います。<h3 id=->ハッシュ関数の役割 - メモリ上のどこに要素を格納するか決める</h3><p>早速<a href=https://www.altus5.co.jp/blog/data-structure/2018/05/07/associative-array/ >前回</a>の内容を引くのですが、 配列を強引に連想配列化した <code>MyAssociativeArray</code>の実装では、 「メモリ上のどこにkey, valueの組を格納するか？」という問題については触れてきませんでした。 ここで、前回実装した連想配列クラス、 <code>MyAssociativeArray</code>における要素代入のメソッドを見直してみましょう。<p><code data-gist-id=06125dd98ffabb584a20c2ae04aecc3b data-gist-line=4-16></code><p>ポイントは、<code>MyAssociativeArray</code>クラスの継承元である<code>Array</code>クラスの<code>push</code>関数を使ってkey, valueの組を格納している点です。 <code>push</code>関数は配列の末尾に要素を追加するメソッドなので、<code>MyAssociativeArray</code>では、新しく到着するkey, valueの組を既存要素の末尾に付け足していくという、ナイーブな方法でメモリ内に格納しています。<p>ハッシュテーブル実装の第一のポイントは、 <strong>メモリ内のどこに要素を格納するか？</strong> について、もう少し計画的なやり方を用いることです。<p>その際に登場するのが、先述した <strong>ハッシュ関数</strong> です。<p><img src=/images/blog/hashtable/MyHashTable.jpg alt=""><p>ハッシュを噛ませた場合の実装イメージ（要素格納の方法）を上図に表してみました。<p><strong>データ代入の手続き</strong><ol><li>あらかじめメモリ上の決まった広さの領域を確保しておく<ul><li>本記事ではテーブルサイズと呼ぶこととします</ul><li>key, valueを受け取ったら、<strong>ハッシュ関数</strong> にkeyを入力<li><strong>ハッシュ値</strong> を得て、1.で確保した領域のサイズ<code>TABLESIZE</code>で割った値 <code>offset</code> を得ることで、メモリ上のどこに格納するかを決める</ol><p>それぞれ、実際にハッシュテーブルを実装したコード（<code>hashtable.rb</code>）を参照しつつ、解説していきたいと思います。<p>今回、Arrayオブジェクトをインスタンス変数として持つ<code>MyHashTable</code>クラスを実装することで、ハッシュテーブルの実装をしてみたいと思います。 まず、1.で述べた「決まった広さの領域を確保する」ことからです。今回は下記のように行います：<p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=7-9></code><p>あらかじめ定めた定数 <code>TABLESIZE</code> の要素数をもつ配列（<code>Array</code>オブジェクト）を生成し、インスタンス変数 <code>@arr</code> として保持しているだけの単純なコードです。 これで、メモリ上にkey, valueの組を保持するための領域が確保されます。 （ <code>TABLESIZE</code>の適切な決め方については、後ほど触れたいと思います。）<p>次に、代入処理を見てみましょう。（上述した流れの2, 3にあたる部分です。） 代入処理ではまず、確保した配列領域のどの位置にkey, valueの組を格納するかを決定します。配列の先頭から要素いくつ分後ろに格納するかを表す<code>offset</code>変数を用意し（０オリジン）、ここに数値を代入します。 （もちろん、 <code>0 &lt;= offset &lt; TABLESIZE</code>を満たすような値を与える必要があります。）<p>さて、肝心の<code>offset</code>の数値は下記コードで決定されています。<p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=11-12></code><p>右辺の<code>MyHashFunction</code>クラスの<code>one_at_a_time</code>メソッドを呼び出し、引数として<code>k</code>（key）を渡しています。それを<code>TABLESIZE</code>で割った値を<code>offset</code>として採用しています。<p>ここで、この<code>one_at_a_time</code>こそが <strong>ハッシュ関数</strong> と呼ばれるものです。 One at a timeハッシュは、質の良いハッシュ関数について論じた<a href=http://www.burtleburtle.net/bob/hash/doobs.html>Jenkinsの文献（英語）</a>に記載されている中で、もっとも古典的なハッシュ関数です。 シンプルなアルゴリズムで動作の理解が易しいこと、デモとしては十分な性能があることから、今回の目的にピッタリと判断しました。動作を理解するのに必要な知識は <strong>ビット演算のみ</strong> ですので、不慣れな方は、ビット演算に関する文献を片手に読めば十分理解できるのではないかと思います。<p><code>one_at_a_time</code>ハッシュ関数の中身をみてみましょう。<p><code data-gist-id=4f3b53612e9764119ce8a3be9aa475d8 data-gist-line=4-17></code><p>ここで、上記コードは下記４つのステップで説明できます。<ol><li>key文字列の先頭から1文字取り出し、文字コード化し、二進数化する（L7）<li>1.で得られた値を<code>hash</code>変数に加える（L7）<li><code>hash</code>変数の値をビット演算でいい感じにかき混ぜる（L8-L9）<li>以下、文字列の末尾文字まで繰り返し<li>得られた値を最後にもう一度かき混ぜて出力（L11-L14）</ol><p>例えば、このハッシュ関数に&quot;altus&quot;というkeyを入力してみると、<code>0x25746a3b</code>という出力値が返されます。この数値を <strong>ハッシュ値</strong> と呼びます。<p>ハッシュ値を<code>TABLESIZE</code>で割った値を<code>offset</code>として採用することで、配列内のどの位置に要素を格納するかを決定します。<p>このようにして<code>offset</code>を確定したら、その位置にkey, valueの組を格納します。 ただし、最初の実装と同様、「既にそのkeyをもつ要素が格納されていれば、値を上書きする」よう実装する必要がありますので、ロジックは若干長くなります。 下記コードのL21が、肝心の代入を行なっている箇所です。<p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=14-28></code><h3 id=->ハッシュ関数に求められる２つの性質</h3><ol><li>上記手続きには一切ランダム性がなく、同一のkeyを与えた時は必ず同じ出力値を返すこと（入力に対する出力の一意性）<li>異なるkeyを与えたとき、同じ出力値を返す可能性が極めて低いこと</ol><h2 id=-key->ハッシュテーブルにおける値の参照 - keyのハッシュ値で格納場所がわかる</h2><p>代入の次は参照です。最初の実装では線形走査でkeyにヒットする要素を見つけていましたが、今回は代入の方法が変わったため、参照の方法が劇的に効率的になります。 ポイントは明快で、 <strong>参照にもkeyのハッシュ値を使えば良い</strong> のです。<p><img src=/images/blog/hashtable/MyHashTable_altus.jpg alt=""><p>今回、代入時の要素格納を、keyのハッシュ値に基づいて行うようロジックを変更しました。そのため、要素参照時にもハッシュ値を発行し、ハッシュ値の指す位置を調べることで、与えられたkeyをもつ要素が、既に連想配列内にあるかどうかを高速に調べることができるのです。 実装方針としては、下記の通りです。<ol><li>keyに対応するハッシュ値からoffsetを求める<li>offsetの指す位置に、与えられたkeyを持つ要素が格納されているかどうかを調べる</ol><p>「keyに対応するハッシュ値からoffsetを求める」コードは下記の通りで、代入の時と全く同一です。<p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=32-33></code><p>「offsetの指す位置に、与えられたkeyを持つ要素が格納されているかどうかを調べる」コードは下記の通りです。<p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=38-54></code><p>まとめると、ハッシュテーブルの実装上の工夫、およびその結果としての性能の良さ（高速さ）は、下記の文章で言い表すことができます。<ul><li>ハッシュテーブルでは、値の代入と参照を同じ手段（ハッシュ関数）を介して行うため、 <strong>１回</strong> の等値判定で指定のkeyを持つ要素が見つかる<li>同様の理由から、指定のkeyをもつ要素が連想配列内に存在しない場合は、 <strong>１回</strong> の等値判定でそのことがわかる<ul><li>ただし、いずれも例外あり（後述する『衝突』が起きた場合）</ul></ul><p>このことが、 <strong>ハッシュテーブルは定数時間O(1)で値の参照/代入が可能である</strong> という文言の意味するところなのですね。<h2 id=-collision->衝突(collision)とは？ - ハッシュテーブルの性能が劣化するケース</h2><p>さて、上記ソースコードを載せつつさらりと流しましたが、性能に関して見過ごせない点があったことにお気づきだったでしょうか。 「ハッシュテーブルは１回の等値判定で参照/代入ができる！」などと言いつつ、 実は今回も、 <strong>参照/代入の実装において線形走査(each)を使っていた</strong> のですね。<p><strong>代入</strong><p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=18-24></code><p><strong>参照</strong><p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=43-49></code><p>さて、こちらは <strong>衝突(collision)に対する処理</strong> と呼ばれるもので、ハッシュテーブルに実装について書かれた文献であれば、必ず言及されている重要な処理です。<p>衝突とは、 <strong>相異なる複数の入力キーに対して、同じハッシュ値が発行されること、もしくは配列内の同じ位置（offset）が格納場所として指定されてしまうこと</strong> を指します。<p>One-at-a-timeハッシュは、古典的ながらもよく考慮されたハッシュ関数ですので、相異なる複数の入力キーに対して同じハッシュ値を発行してしまうことは稀ですが、 その出力値は <code>0</code>以上<code>2^31</code>未満と幅が大きいことから、今回は実用上<code>TABLESIZE</code>を指定し、One-at-a-timeの出力値を<code>TABLESIZE</code>で割った値を用いることで、値を<code>0</code>以上<code>TABLESIZE</code>未満に補正して用います。<p>今回の実装では、<code>TABLESIZE</code>は<code>52291</code>を指定していましたので、ある程度大きな要素数になると、かなりの高確率で衝突が生じることになります。<h3 id=->ハッシュテーブルのサイズに関する余談</h3><p>この時<code>TABLESIZE</code>を<code>365</code>と指定してみると、 有名な「誕生日のパラドックス」と同じ問題設定になります。 「<quote>何人集まれば、その中に誕生日が同一の2人（以上）がいる確率が、50%を超えるか?</quote>」という問題に対する答えを問うもので、 その答えは <strong>「23人」</strong> であるという、意外な結論が有名です。 この興味深い結果をハッシュ値の文脈に載せてみると、<p>前提：<code>TABLESIZE</code>を<code>365</code>に指定し、理想的なハッシュ関数を用いたとする<p>主張：keyについてランダムに要素を追加する場合、 <strong>要素数が「23」に達するまでに１回以上の衝突が起きる確率は50%以上</strong> である<p>と読み換えることができ、誕生日のパラドックスは上記の主張が「正しい」ことを示す、技術的にもおもしろい（厄介な）帰結だということが分かります。<p>さて、話が逸れましたが、<code>TABLESIZE</code>をどんなに大きくした場合でも、衝突の起きる確率は０にはなりませんので、プログラム上はその際の処理を書いておく必要が生じます。 それが、先ほど挙げた参照/代入のロジックにおけるeach文の役割だったのですね。<p>以下、その内容を再掲・解説しておきますので、ご興味のある方はコードを解読してみてください。<h3 id=->代入における衝突対策ロジック</h3><p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=11-29></code><ol><li>新規のkeyに対する<code>offset</code>の位置に既存の要素が存在するかどうかを確かめる(L14)<li>存在しない場合は単純に要素を格納すればOK<ul><li>ただし、今後衝突が起きた時のため配列を作っておき、いま代入したいkey, valueはその先頭要素として格納しておく(L15)</ul><li>存在する場合は、既存keyの再入力（keyに対する値の上書き）か、異なるkeyに対するoffsetの重複（衝突）かを判定する(L18-L19)<li>keyに対する値の上書きの場合は、上書き処理を行う(L21)<li>衝突の場合は、以前に入力されたkey, valueにおいて、上記2.の手続きで配列を準備してあるので、その末尾にいま入力したいkey, valueをpushする(L26)</ol><h3 id=->参照における衝突対策ロジック</h3><p><code data-gist-id=43f4e9a2629d0d4dc71791fdba1d399c data-gist-line=38-56></code><ol><li>クエリとして投げられたkeyに対する<code>offset</code>の位置に要素が存在するかどうかを判定する(L39)<li>存在しない場合、nilを返す<li>存在する場合、<code>@arr[offset]</code>の要素に対して「クエリ」と「格納されているkey」との等値判定を行い、求める要素があるかどうかを調べる<ul><li>ここで<code>@arr[offset]</code>内に複数要素が存在するのは、過去に衝突が起きた場合である。多くの場合、<code>@arr[offset]</code>の要素数は１であるため、eachループは１回しか回らない</ul></ol><h2 id=->まとめ</h2><p>今回、コードを読みやすく、保守・拡張しやすくしてくれる「連想配列」について、その原理に迫ってみました。 定数時間O(1)で要素へのアクセスを可能にする実装の一つに「ハッシュテーブル」があり、その構成要素として「ハッシュ関数」が重要な役割を果たしていることを、Rubyで実際に連想配列を実装してみることでおさらいしてみました。 <a href=https://www.altus5.co.jp/blog/data-structure/2018/05/07/associative-array/ >前回</a>の冒頭で述べた「連想配列は配列ではない」という（物騒な）主張は、本記事でまとめた内容をゼミで学んで以来、実装と実験によって体感できた実体験に基づいています。 インタフェースが一見同じでも、内部の仕組みは随分違うし、そのことに助けられることがあるんだなぁ…と感動したことを覚えています。<p>普段ツールとして見ている/使っている実装について、 <strong>内部の仕組みがわかるといちいち感動できる</strong> 、そんな経験が広がっていけば、プログラミングはますます深く、楽しくなるのではないでしょうか。 （綺麗にまとめてみました！）<h2 id=->参考資料</h2><ul><li><a href=https://github.com/msato-ok/hash>本記事のソースコード（GitHub）</a></ul></div></div><div id=blog-menu><span><strong>最近の記事</strong></span><ul><li class=recent><a href=/blog/document/2019/04/29/markdown-to-confluence/ >Confluenceのドキュメントをマークダウンで書きたい</a><li class=recent><a href=/blog/angular/2019/04/10/angular-error-hadling-implement/ >Angularのエラー処理について考える（実装編）</a><li class=recent><a href=/blog/angular/2019/03/30/angular-error-hadling-design/ >Angularのエラー処理について考える（設計編）</a><li class=recent><a href=/blog/document/2018/10/13/write-spec-with-markdown/ >仕様書をマークダウンで書きたい</a><li class=recent><a href=/blog/data-structure/full-text-search/2018/07/18/full_text_search/ >全文検索を自社サイト・社内サーバーに構築したいクライアントのための留意点</a></ul><span><strong>タグ</strong></span><ul><li class="tag-color-label tag__0"><a href=/blog/tag/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E6%8A%80%E8%A1%93%E7%B7%8F%E8%A6%A7/ >プログラミング技術総覧 (16)</a><li class="tag-color-label tag__1"><a href=/blog/tag/Actor%E3%83%A2%E3%83%87%E3%83%AB/ >Actorモデル (1)</a><li class="tag-color-label tag__2"><a href=/blog/tag/%E3%83%AA%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/ >リアクティブプログラミング (1)</a><li class="tag-color-label tag__3"><a href=/blog/tag/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/ >機械学習 (6)</a><li class="tag-color-label tag__4"><a href=/blog/tag/%E9%9D%99%E7%9A%84%E3%82%B5%E3%82%A4%E3%83%88/ >静的サイト (1)</a><li class="tag-color-label tag__5"><a href=/blog/tag/%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89/ >環境構築 (5)</a><li class="tag-color-label tag__6"><a href=/blog/tag/Docker/ >Docker (5)</a><li class="tag-color-label tag__7"><a href=/blog/tag/AngularJS/ >AngularJS (2)</a><li class="tag-color-label tag__8"><a href=/blog/tag/React/ >React (2)</a><li class="tag-color-label tag__9"><a href=/blog/tag/%E3%82%A2%E3%83%AB%E3%82%BF%E3%82%B9%E3%83%95%E3%82%A1%E3%82%A4%E3%83%96/ >アルタスファイブ (2)</a><li class="tag-color-label tag__10"><a href=/blog/tag/Vagrant/ >Vagrant (1)</a><li class="tag-color-label tag__11"><a href=/blog/tag/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/ >プログラミング (1)</a><li class="tag-color-label tag__0"><a href=/blog/tag/Laravel/ >Laravel (1)</a><li class="tag-color-label tag__1"><a href=/blog/tag/OAuth/ >OAuth (1)</a><li class="tag-color-label tag__2"><a href=/blog/tag/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/ >アルゴリズム (2)</a><li class="tag-color-label tag__3"><a href=/blog/tag/DB/ >DB (2)</a><li class="tag-color-label tag__4"><a href="/blog/tag/Let's%20Encrypt/">Let&#39;s Encrypt (1)</a><li class="tag-color-label tag__5"><a href=/blog/tag/Chainer/ >Chainer (1)</a><li class="tag-color-label tag__6"><a href=/blog/tag/%E3%83%9E%E3%83%AB%E3%82%B3%E3%83%95%E9%80%A3%E9%8E%96/ >マルコフ連鎖 (1)</a><li class="tag-color-label tag__7"><a href=/blog/tag/Trie/ >Trie (2)</a><li class="tag-color-label tag__8"><a href=/blog/tag/LOUDS/ >LOUDS (1)</a><li class="tag-color-label tag__9"><a href=/blog/tag/%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E5%87%A6%E7%90%86/ >テキスト処理 (2)</a><li class="tag-color-label tag__10"><a href=/blog/tag/%E5%BD%A2%E6%85%8B%E7%B4%A0%E8%A7%A3%E6%9E%90/ >形態素解析 (2)</a><li class="tag-color-label tag__11"><a href=/blog/tag/Web%20Performer/ >Web Performer (1)</a><li class="tag-color-label tag__0"><a href=/blog/tag/Spring%20Boot/ >Spring Boot (1)</a><li class="tag-color-label tag__1"><a href=/blog/tag/Spring%20Framework/ >Spring Framework (2)</a><li class="tag-color-label tag__2"><a href=/blog/tag/%E6%9B%B8%E8%A9%95/ >書評 (1)</a><li class="tag-color-label tag__3"><a href=/blog/tag/%E7%B5%84%E7%B9%94%E5%BF%83%E7%90%86%E5%AD%A6/ >組織心理学 (1)</a><li class="tag-color-label tag__4"><a href=/blog/tag/%E3%82%B2%E3%83%BC%E3%83%A0%E7%90%86%E8%AB%96/ >ゲーム理論 (1)</a><li class="tag-color-label tag__5"><a href=/blog/tag/Python/ >Python (1)</a><li class="tag-color-label tag__6"><a href=/blog/tag/Double%20array/ >Double array (1)</a><li class="tag-color-label tag__7"><a href=/blog/tag/%E6%9C%80%E9%81%A9%E5%8C%96/ >最適化 (2)</a><li class="tag-color-label tag__8"><a href=/blog/tag/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E9%96%8B%E7%99%BA/ >システム開発 (6)</a><li class="tag-color-label tag__9"><a href=/blog/tag/TERASOLUNA/ >TERASOLUNA (1)</a><li class="tag-color-label tag__10"><a href=/blog/tag/%E7%B5%B1%E8%A8%88%E5%AD%A6/ >統計学 (1)</a><li class="tag-color-label tag__11"><a href=/blog/tag/%E3%83%87%E3%83%BC%E3%82%BF%E5%8F%AF%E8%A6%96%E5%8C%96/ >データ可視化 (1)</a><li class="tag-color-label tag__0"><a href=/blog/tag/R/ >R (1)</a><li class="tag-color-label tag__1"><a href=/blog/tag/%E8%B2%A9%E5%A3%B2%E7%AE%A1%E7%90%86%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/ >販売管理システム (1)</a><li class="tag-color-label tag__2"><a href=/blog/tag/%E7%94%A8%E8%AA%9E%E9%9B%86/ >用語集 (2)</a><li class="tag-color-label tag__3"><a href=/blog/tag/%E3%83%9C%E3%83%88%E3%83%AB%E3%83%8D%E3%83%83%E3%82%AF/ >ボトルネック (2)</a><li class="tag-color-label tag__4"><a href=/blog/tag/Jupyter%20Notebook/ >Jupyter Notebook (1)</a><li class="tag-color-label tag__5"><a href=/blog/tag/%E4%BB%95%E4%BA%8B%E5%8A%B9%E7%8E%87%E5%8C%96/ >仕事効率化 (1)</a><li class="tag-color-label tag__6"><a href=/blog/tag/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/ >データ構造 (4)</a><li class="tag-color-label tag__7"><a href=/blog/tag/%E5%AE%9F%E8%A3%85/ >実装 (2)</a><li class="tag-color-label tag__8"><a href=/blog/tag/%E9%80%A3%E6%83%B3%E9%85%8D%E5%88%97/ >連想配列 (1)</a><li class="tag-color-label tag__9"><a href=/blog/tag/Ruby/ >Ruby (2)</a><li class="tag-color-label tag__10"><a href=/blog/tag/%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB/ >ハッシュテーブル (1)</a><li class="tag-color-label tag__11"><a href=/blog/tag/%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E5%9C%A7%E7%B8%AE/ >テキスト圧縮 (1)</a><li class="tag-color-label tag__0"><a href=/blog/tag/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%9C%A7%E7%B8%AE/ >ファイル圧縮 (1)</a><li class="tag-color-label tag__1"><a href=/blog/tag/%E5%85%A8%E6%96%87%E6%A4%9C%E7%B4%A2/ >全文検索 (1)</a><li class="tag-color-label tag__2"><a href=/blog/tag/%E4%BB%95%E6%A7%98%E6%9B%B8/ >仕様書 (2)</a><li class="tag-color-label tag__3"><a href=/blog/tag/%E3%83%9E%E3%83%BC%E3%82%AF%E3%83%80%E3%82%A6%E3%83%B3/ >マークダウン (2)</a><li class="tag-color-label tag__4"><a href=/blog/tag/a5doc/ >a5doc (2)</a><li class="tag-color-label tag__5"><a href=/blog/tag/Angular/ >Angular (2)</a><li class="tag-color-label tag__6"><a href=/blog/tag/%E3%82%A8%E3%83%A9%E3%83%BC%E5%87%A6%E7%90%86/ >エラー処理 (2)</a><li class="tag-color-label tag__7"><a href=/blog/tag/SPA/ >SPA (2)</a><li class="tag-color-label tag__8"><a href=/blog/tag/Confluence/ >Confluence (1)</a></ul></div></div><div class=w_const><div id=fb-root></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.8&appId=331911723808007";
            fjs.parentNode.insertBefore(js, fjs);
          }(document, 'script', 'facebook-jssdk'));</script><ul class=socialbuttons><li class=twitter><a href=https://twitter.com/share class=twitter-share-button>Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script><li class=facebook><div class=fb-like data-href=https://www.altus5.co.jpundefined data-layout=box_count data-action=like data-size=small data-show-faces=false data-share=false></div><li class=hatena><a href=http://b.hatena.ne.jp/entry/ class=hatena-bookmark-button data-hatena-bookmark-layout=vertical-normal data-hatena-bookmark-lang=ja data-hatena-bookmark-title=%u300C%u30CF%u30C3%u30B7%u30E5%u300D%u5B8C%u5168%u7406%u89E3%u306E%u305F%u3081%u306E%u899A%u66F8%20%u30CF%u30C3%u30B7%u30E5%u30C6%u30FC%u30D6%u30EB%u3092Ruby%u3067%u5B9F%u88C5%u3057%u3066%u307F%u308B title=このエントリーをはてなブックマークに追加><img src=https://b.st-hatena.com/images/v4/public/entry-button/button-only@2x.png alt=このエントリーをはてなブックマークに追加 width=20 height=20 style="border: none"></a><script src=https://b.st-hatena.com/js/bookmark_button.js charset=utf-8 async></script><li class=pocket><a data-pocket-label=pocket data-pocket-count=vertical class=pocket-btn data-lang=ja></a><script>!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script><li class=feedly><a href=//feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fwww.altus5.co.jp%2Ffeed.xml target=blank><img id=feedlyFollow src=http://s3.feedly.com/img/follows/feedly-follow-rectangle-volume-small_2x.png alt="follow us in feedly" width=66 height=20></a></ul><div class=relate><h1>関連記事</h1><ul><li class=post-link><span class=post-date>2018/05/07 </span><a class=post-title href=/blog/data-structure/2018/05/07/associative-array/ >Rubyの配列(Array)を魔改造して、連想配列として使ってみた </a><span class=post-description><a href=/blog/data-structure/2018/05/07/associative-array/ >連想配列をRubyで実装することを通じ、普段我々が使っている連想配列の性能について理解することを目指した記事です。Rubyの配列(Array)を連想配列に魔改造するための、30行ほどの短いコードをGitHubで公開しています。</a></span><li class=post-link><span class=post-date>2018/07/18 </span><a class=post-title href=/blog/data-structure/full-text-search/2018/07/18/full_text_search/ >全文検索を自社サイト・社内サーバーに構築したいクライアントのための留意点 </a><span class=post-description><a href=/blog/data-structure/full-text-search/2018/07/18/full_text_search/ >システム開発における「全文検索」の実装方式・コスト・性能に関して、クライアント企業の方にも腹落ち頂けるようまとめました。grep型と索引型の違いに関する平易な解説を記載しているので、これらをクライアントに解説されたい開発者にもオススメです。</a></span><li class=post-link><span class=post-date>2018/06/14 </span><a class=post-title href=/blog/data-structure/file-compress/2018/06/14/file_compress_extensions/ >zip, compress, gzip, bzip2 - ファイル圧縮の形式に関する覚書 </a><span class=post-description><a href=/blog/data-structure/file-compress/2018/06/14/file_compress_extensions/ >ファイルサイズや検索性に大きく影響する「圧縮形式」。本記事ではメジャーな圧縮形式について紹介していくと共に、『高速文字列解析の世界』（岡野原、2012）の内容と連動。エンジニアが処理内容を学習しやすいようまとめています。</a></span></ul></div></div></article><article id=scout class=article><h1 class="scout_title w_const">＼(＾▽＾*) 私たちと一緒に働いてみませんか？ (*＾▽＾)／</h1><div class="article__conts w_const"><section class="content01 content"><p>少しでも興味をお持ちいただけたら、お気軽に、お問い合わせください。<p><a href=/contact/entry/ >採用応募受付へ</a><p>(採用応募じゃなく、ただ、会ってみたいという方も、大歓迎です。)</section></div></article></div><footer id=_footer><nav class=w_const><div class="content01 cf"><div class=profile><h1 class=foot_logo><a href=/ ><img src=/images/logo_footer.png alt=Altus-Five（アルタスファイブ）></a></h1><div class=address><p class=paragraph>〒160-0022<p class=paragraph>東京都新宿区新宿2-1-9 ステラ新宿5F<p class=paragraph><a href=tel:03-6904-5573>TEL：03-6904-5573</a></div></div><ul class="links links01"><li class=link><a href=/ >TOP</a><li class=link><a href=/#introduction>アルタスファイブとは</a><li class=link><a href=/#feature>強み</a><li class=link><a href=/#service>サービス</a><li class=link><a href=/#performance>実績</a><li class=link><a href=/#example>開発事例</a><li class=link><a href=/blog/ >ブログ</a></ul><ul class="links links02"><li class=link><a href=/recruit/ >採用情報</a><li class=link><a href=/company/ >会社概要</a><li class=link><a href=/privacy/ >個人情報保護方針</a><li class=link><a href=/contact/ >お問い合わせ</a></ul><ul class=marks><li class=mark><img src=/images/p_mark.png alt=""></ul></div><div id=copyright>© 2016 Altus-Five Co.,LTD. ALL RIGHTS RESERVED.</div></nav></footer><script src="/scripts/vendor.js?rev=0222573b207f1383f49b8afd2629c0fd"></script><script>$(function() {
      var fout = false;
      var orgFontFamily;
      if (fout) {
        var orgFontFamily = $('body').css('font-family');
        $('body').css({'font-family': "'Helvetica', 'Arial', 'メイリオ', 'Meiryo', 'MS  PGothic', 'ヒラギノ角ゴ Pro W3', 'Hiragino Kaku Gothic Pro', sans-serif"});
      }
      WebFont.load({
        google: {
          families: [
            "PT Sans Narrow:n4,n7"
          ]
        },
        custom: {
          families: [
            "Noto Sans Japanese:n4,n7"
          ]
        },
        timeout: 3000,
        loading: function() {
          // ロードしているとき allfonts
        },
        active: function() {
          // Web Fontが使用可能になったとき allfonts
        },
        inactive: function() {
          // ブラウザがサポートしていないとき allfonts
        },
        fontloading: function(fontFamily, fontDescription) {
          // fontFamilyをロードしているとき onefont
        },
        fontactive: function(fontFamily, fontDescription) {
          // fontFamilyが使用可能になったとき onefont
          if (fout) {
            if ('Noto Sans Japanese' === fontFamily) {
              $('body').css({'font-family': orgFontFamily});
            }
          }
        },
        fontinactive: function(fontFamily, fontDescription) {
          // fontFamilyをブラウザがサポートしていないとき onefont
        }
      });
    });</script><script src="/scripts/common.js?rev=88ed76e81255e2c8404edb27a6c51044"></script><script src="/scripts/jquery.tile.min.js?rev=24209686ddcda6d9849f65fb20bede19"></script><script type=text/x-mathjax-config>MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ['\\(','\\)'] ],
        processEscapes: true
      }
    });</script><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>